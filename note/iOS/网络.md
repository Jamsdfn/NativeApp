# 网络

## URL

Uniform Resource Locator(统一资源定位符)，网络中每一个资源都对应唯一的地址—URL。

- URL的基本格式

  - 协议://主机地址:端口号/路径

    - 协议： 不同的协议代表不同的资源获取方式

    - 主机地址：主机的唯一标示(IP地址、域名)

    - 路径：资源在主机中的具体位置

  - 举例：

    - http://www.itheima.com/
    - http://www.itheima.com/images/xx00.png
    - ftp://www.itheima.com/movies/cls.avi

- URL的常见协议

- -  HTTP、FTP、mailto、File、tel://、sms://

## HTTP简介

- HyperText Transport Protocol(超文本传输协议)
  - 浏览器和Web服务器通讯时候遵守的约定
  - 互联网使用最多的协议
  - 提供超文本传输服务
  - 通过浏览器打开网站使用的就是HTTP提供的服务，开发App也会经常使用HTTP协议从网络上获取数据

- ### TCP和UDP

- 简单来说TCP协议传输得到的数据是正确的，而UDP得到的数据是有可能有问题的，因为TCP在网络层的协议一定有校验码，而UDP是不一定要校验码的，因此无法确保100%正确，现在阶段的网络传输误码率是非常非常低的，因此UDP也还是不错的选择

- TCP: 要求可靠性高的时候用，因为TCP在建立连接器要经过三次通信才会建立连接通道，并且校验发现错误会要求重发。（比如下载）

- UDP: 要求实时性比较高，经济实惠省流量的时候使用。直接就建立连接的通道，数据错误也不会要求重发（比如打电话，直播）

## Socket（套接字）


Socket又称“套接字”，应用程序通过“套接字”向网络发送请求或向网络做出应答。

网络通信其实就Socket之间的通信，数据在两个Socket之间通过IO传输数据，Socket是纯C语言的，是跨平台的，**HTTP协议是基于Socket的，HTTP协议的底层使用的就是Socket**。Socket就是在应用层和传输层之间的协议。

**Socket的通信过程**：

- 创建Socket

  - 导入头文件
    - \#import <sys/socket.h>
    - \#import <netinet/in.h>
    - \#import <arpa/inet.h>

  - 创建Socket`int socket(int domain, int type, int protocol);`
    - 参数1 domain 协议域 AF_INET--IPV4
    - 参数2 type  socket类型 SOCK_STREAM(TCP)/SOCKET_DGRAM(UDP)
    - 参数3 protocol IPPROTO_TCP/IPPROTO_UDP  如果 传入0 会根据第二个参数选择合适的值
    - 返回值 >0 创建成功 socket的描述符

  - 示例：int clientSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

- 连接到服务器

  - 定义函数：int connect(int sockfd, struct sockaddr * serv_addr, int addrlen);
    - sockfd：标识一个套接字。
    - serv_addr：结构体套接字s想要连接的主机地址和端口号。
    - addrlen：结构体的长度。

  ```objc
  struct sockaddr_in addr;
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = inet_addr("192.168.88.100");
  addr.sin_port = htons(3000);
  int result = connect(clientSocket, (const struct sockaddr *) &addr, sizeof(addr));
  // 返回值为0则连接成功，非零则连接失败
  ```

- 发送数据给服务器

  ```objc
  NSString *sendMsg = @"GET / HTTP/1.1\r\n"
                       "Host: www.baidu.com\r\n"
                       "Connection: close\r\n\r\n"];
  // 自己封装好请求头（遵守HTTP协议），才发送给服务器发送
  const char *sendMessage = sendMsg.UTF8String;
  ssize_t sendLen = send(clientSocket, sendMessage, strlen(sendMessage), 0);
  NSLog(@"发送的字节数：%ld",sendLen);
  ```

- 从服务器接收数据

  ```objc
  uint8_t buffer[1024];
  ssize_t recvCount = -1;
  NSMutableData *mData = [NSMutableData new];
  do {
      // 循环接收数据，直到服务器传完了才停止
      recvCount = recv(self.clientSocket, buffer, sizeof(buffer), 0);
      if (recvCount) {
          [mData appendBytes:buffer length:recvCount];
      }
  }while(recvCount != 0);
  NSString *res = [[NSString alloc] initWithData:mData encoding:NSUTF8StringEncoding];
  return res;
  ```

- 关闭连接 `close(clientSocket);`

- 获得响应体的内容，即响应头去掉

  ```objc
  // 截取响应头结束位置
  NSRange range = [res rangeOfString:@"\r\n\r\n"];
  // 在响应头结束位置后开始获得html
  NSString *html = [res substringFromIndex:range.location+range.length];
  ```

## JSON 解析

NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:0 error:&error];

- 参数一：NSData类型的二进制数据
- 参数二：options：
  - 0 （通常都传这个）
    - 不做任何处理
  - NSJSONReadingMutableContainers = (1UL << 0) 
    - 把容器（最外层）转成可变的数组或者可变的词典
  -  NSJSONReadingMutableLeaves = (1UL << 1)
    - 如果json内所有东西都变成可变的
  -  NSJSONReadingFragmentsAllowed = (1UL << 2)
    - 如果不是合法的JSON格式，也解析（通常都不用）
- 参数三：NSError 一个对象的地址

```objc
NSError *error;
NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:0 error:&error];
if (error) {
    NSLog(@"JSONparse error: %@",error);
    return;
}
NSLog(@"%@",dict);
```

**解决输出是Unicode源码的问题**：给数组或者字典写一个类扩展，改写其descriptionWithLocale方法Xcode8以前

```objc
- (NSString *)descriptionWithLocale:(id)locale{
    NSMutableString *msg = [NSMutableString new];
    [msg appendString:@"\r\n{\r\n"];
    for (id key in self) {
        [msg appendFormat:@"\t%@: %@,\r\n", key, self[key]];
    }
    [msg appendString:@"}"];
    return msg.copy;
}
```

xcode8以后重写的方法就变了descriptionWithLocale:indext:level: 默认调用变成这个方法了

```objc
- (NSString *)descriptionWithLocale:(id)locale indent:(NSUInteger)level{
    NSMutableString *msg = [NSMutableString new];
    [msg appendString:@"\r\n{\r\n"];
    for (id key in self) {
        [msg appendFormat:@"\t%@: %@,\r\n", key, self[key]];
    }
    [msg appendString:@"}"];
    return msg.copy;
}
```

为了可以nslog类中的方法我们可以重写类的 description方法

```objc
- (NSString *)description
{
    return [NSString stringWithFormat:@"<%@: %p> {videoId: %@, name: %@, length: %@, videoURL: %@, imageURL: %@, desc: %@, teacher: %@, time: %@}", [self class], self, self.videoId, self.name, self.length, self.videoURL, self.imageURL, self.desc, self.teacher, self.time];
}
```

一个分类文件里面可以写多个分类，因此我们可以创建一个文件数组和字典都重写这个方法就好了。

**注意**：我们给JSON做字典转模型的时候一些数组类型我们都用NSNumber接收，因为有可能服务器返回的是null，用int、float这些接收会报错

## Plist 解析

开发的时候无论是网络还是本地通常都不用plist，首先数据量大，再者不可能只做iOS，plist别的语言是解析不了的

```objc
NSError *error;
NSArray *arr = [NSPropertyListSerialization propertyListWithData:data options:0 format:0 error:&error];
if (error) {
    NSLog(@"plistparse error: %@",error);
    return;
}
NSLog(@"%@",arr);
```

## XML

- 什么是XML

  - Extentsible Markup Language（可扩展标记语言）
  - HTML （超文本标记语言）XML与HTML十分类似
  - 非常类似于HTML，HTML的作用是显示数据，XML的目的是存储和传输数据
  - XML是各种应用之间传输数据是以前常用的格式，现在几乎不用，都用JSON
  - W3C的推荐标准
- XML由标记组成
- <tag> 这就是标记，xml的标记是可扩展的，没有预定义
- 有且只有一个根节点
```objc
<Human>
    <Person color="yellow" weight="130" height="150">
        <name>wg</name>
        <age>108</age>
    </Person>
    <Student name="y" />
</Human>
```

- XML格式的解析方式

  - SAX ：iOS上解析，速度快，内存占用小，只读
  - DOM ： mac上的解析方式，iOS无法直接使用，解析过程中内存占用大，读写

- SAX的解析步骤：

  a. 加载xml数据

  b. 找开始节点(包括节点的属性)

  c. 找节点之间的内容

  d. 找结束节点

  e. 直到最后一个节点，解析结束
  
- 网络模型中用copy修饰类中的属性，包括NSNumber

- 否则的话KVC赋值的value是NSMutableString的时候会有问题，值是可变字符串中的最后一个值

```objc
NSXMLParser *parser = [[NSXMLParser alloc] initWithData:data];
// 设置代理, 在哪个线程设置代理，代理方法就执行在那个线程
parser.delegate = self;
// parse方法代表开始执行代理的方法
[parser parse];

// 实现代理方法
- (void)parserDidStartDocument:(NSXMLParser *)parser{
    // 开始解析文档
    
}
- (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary<NSString *,NSString *> *)attributeDict{
    // 找开始节点(包括节点的属性)
    // elementName 节点名称
    // attributeDict 节点标签
    if ([elementName isEqualToString:@"video"]) {
        self.currentVideo = [[MResponse alloc] init];
        self.currentVideo.videoId = @([attributeDict[@"videoId"] intValue]);
        [self.videos addObject:self.currentVideo];
    }
}

- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string{
    // 找节点之间的内容
    [self.mStr appendString:string];
}

- (void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName{
    // 找结束节点
    if (![elementName isEqualToString:@"video"] && ![elementName isEqualToString:@"videos"]) {
        [self.currentVideo setValue:self.mStr forKey:elementName];
    }
    [self.mStr setString:@""];
}

-(void)parserDidEndDocument:(NSXMLParser *)parser{
    // 结束解析文档
    NSLog(@"%@",self.videos);
}

- (void)parser:(NSXMLParser *)parser parseErrorOccurred:(NSError *)parseError{
    // 解析出错
}
```

十分复杂，因此不常用

- DOM方式的解析 Document Object Model

  - DOM--文档对象模型(文档🌲模型)
- 一次性把xml全部加载到内存，内存消耗大
  - 之前的SAX方式只能读取XML，DOM可以修改，添加删除修改节点
- iOS默认不支持DOM解析（不支持NSXML这个类）
  
  - 在iOS解析DOM的话需要第三方框架
    - GData/KissXML(XMPP中使用此框架)
- 适合读写比较小的XML文件
  - 通常用GDataXMLNode这个框架在iOS中使用
    - 引入完这个框架后根据头文件最上方注释的提示
  - 在项目build settings里搜索 Header Search Paths 设置为 /usr/include/libxml2
    - 在项目build settings里搜索 Other Linker Flags 设置为 -lxml2

```objc
NSError *error;
GDataXMLDocument *document = [[GDataXMLDocument alloc] initWithData:data error:&error];
GDataXMLElement *rootElement = document.rootElement;
NSMutableArray *arrM = [NSMutableArray new];
for (GDataXMLElement *ele in rootElement.children) {
    MResponse *v = [MResponse new];
    [arrM addObject:v];
    // 给对象的属性赋值
    // 遍历子标签
    for (GDataXMLElement *subEle in ele.children) {
        //subEle.name 标签的名字 subEle.stringValue就是标签的内容
        [v setValue:subEle.stringValue forKey:subEle.name];
    }
    // 遍历属性
    for (GDataXMLNode *attr in ele.attributes) {
        [v setValue:attr.stringValue forKey:attr.name];
    }
}
if (error) {
    NSLog(@"xmlparse error: %@",error);
    return;
}
NSLog(@"%@", arrM);
```




## 获取网络数据

- 法一：NSData，这种设置方法不能设置请求做一些响应的设置，缓存策略、超时时长、响应头等。

```objc
NSURL *url = [NSURL URLWithString:@"http://127.0.0.1/aaa/demo.json"];
NSData *data = [NSData dataWithContentsOfURL:url];
NSString *str = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
NSLog(@"%@",str);
```

- 法二：NSURLConnection sendAsynchronousRequest，这个API iOS9就过期了

```objc
NSURL *url = [NSURL URLWithString:@"http://192.168.88.100/aaa/demo.json"];
//    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
// **设置缓存策略，和连接延时（超时后不管服务器断不断开连接，客户端都断开**
NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:15];
// 添加响应头
[request setValue:@"Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1" forHTTPHeaderField:@"User-Agent"];
[NSURLConnection sendAsynchronousRequest:request queue:self.queue completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) {
    if (connectionError) {
        NSLog(@"connect error");
        return;
    }
    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse*)response;
    if (httpResponse.statusCode != 200 && httpResponse.statusCode != 304) {
        NSLog(@"server error");
        return;
    }
    NSString *str = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
    NSLog(@"%@", str);
}];
```

- 法三

