# iOS-多线程

多线程的本质就是多个任务同时执行。

## 相关概念

**同步**：多个任务只能依次执行的，如果有一个地方卡住了，整个程序就卡住了（程序阻塞）。

**异步**：多个任务同时执行，一个地方卡住了，程序还能继续往下运行

**进程**：指的是系统中正在运行的应用程序，每个进程之间是独立的，每个进程均运行在其专用的受保护的内存空间内。

**线程**：一个进程有多个线程组成（一个进程至少有一个线程），线程是进程的基本执行单元，一个进程的所有任务都是在线程执行的。

**多线程**：

- 一个进程中可以开启多个线程，一个线程依次执行多个任务

- 多线程可以解决程序阻塞的问题
- 多线程可以提高程序的执行效率

**操作系统**：操作系统有单任务操作系统（可以理解为一次只能执行一个应用）、多任务操作系统（多个应用可以同时执行）。

**CPU**：（单核CPU）

- 同一时间只能处理一个线程，只有一个线程在执行，这时候的多线程的概念其实只是快速在多个线程之间来回切换执行而已。
- 只要cpu调度线程的时间足够快，看起来多个线程就行是同时执行。
- 如果线程非常多，cpu单单在线程之间切换就消耗大量cpu，每个线程被调度的次数就会降低，线程的执行效率也会跟着降低。
- 多核CPU就可以看成是多个单核CPU来理解就行了

**主线程**：程序运行后，默认会开启一个线程，称为主线程或UI线程。主线程一般用来刷新UI界面，处理UI事件。注意：别把耗时的操作放入主线程，耗时的操作会卡住主线程，严重影响UI的流程度，用户体验差

## 多线程的优缺点

优点：

- 能适当提高程序的执行效率
- 能适当的提高资源的利用率（内存，CPU）
- 线程上的人物执行完成后，线程会自动销毁

缺点：

- 开启线程需要占用一定的内存空间（默认情况下，一个线程占512KB）
- 如果开启大量的线程，会占用大量的内存空间，降低程序的性能
- 线程越多，cpu在调度线程上的开销就很大
- 程序设计更加复杂，比如线程间的通信、多线程的数据共享

## iOS中多线程的技术方案

- pthread
  - 一套通用的多线程API，适用于Unix、Linux、Windows等系统，跨平台可移植但使用难度大
  - 用的是C语言，线程的生命周期是由程序员管理的
  - 几乎不用
- NSThread
  - 使用面向对象封装了pthread，简单易用，可直接操作线程对象
  - 用的是OC，线程的声明周期也是有程序员管理的
  - 偶尔使用
- GCD
  - 一个自动管理的线程技术，充分利用设备的多核
  - C语言，线程的生命周期是自动管理的
  - 经常使用
- NSOperation
  - 用面向对象封装了GCD，是GCD的超集，基于GCD，比GCD多了些更简单实用的功能
  - OC，线程的生命周期也是自动管理的
  - 经常使用

### pthread

pthread_create(<#pthread_t _Nullable *restrict _Nonnull#>, <#const pthread_attr_t *restrict _Nullable#>, <#void * _Nullable (* _Nonnull)(void * _Nullable)#>, <#void *restrict _Nullable#>)

- 参数1：线程编号的地址

- 参数2：线程的属性

- 参数3：线程要执行的函数

- 线程4：函数需要的参数

返回值，创建成功还是失败，0成功 1失败

```objc
// 合适的位置 
pthread_t pthread;
NSString *str = @"lisi";
int result = pthread_create(&pthread, NULL, demo, (__bridge void *)(str));
if (result == 0) {
    NSLog(@"成功");
}else{
    NSLog(@"失败");
}
// 要执行的demo函数的函数体
void *demo(void *param) {
    NSString *str = (__bridge NSString *)(param);
    NSLog(@"hello %@",str);
    return NULL;
}
```

### NSThread

常见NSThread对象后 调用 [对象名 start];

- [[NSThread alloc] initWithTarget:<#(nonnull id)#> selector:<#(nonnull SEL)#> object:<#(nullable id)#>]
  - 参数一：方法所属的对象
  - 参数二：方法
  - 参数三：方法的参数，类型是id，只要是OC对象都行
- [[NSThread alloc] initWithBlock:^{<#code#>}]
  - 参数：block，不能穿参数

直接调用类方法

- [NSThread detachNewThreadSelector:@selector(demo:) toTarget:self withObject:@{@"name":@"jack"}];
- [NSThread detachNewThreadWithBlock:^{NSLog(@"test %@",[NSThread currentThread]);}];

当前控制器的self让方法后台执行

- [self performSelectorInBackground:@selector(demo:) withObject:@{@"name":@"jerry"}];

```objc
// way 1
NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(demo) object:@{@"name":@"Thread1"}];
[thread start];// 记得要调用start方法
- (void)demo{
     NSLog(@"%@ %@",sender[@"name"], [NSThread currentThread]);// 查看当前线程的信息
}
// way 2
[[NSThread alloc] initWithBlock:^{
	 NSLog(@"test %@",sender[@"name"], [NSThread currentThread]);
}]

// way 3 类方法，直接创建并且调用
[NSThread detachNewThreadSelector:@selector(demo:) toTarget:self withObject:@{@"name":@"jack"}];
// way 4 
[NSThread detachNewThreadWithBlock:^{
    NSLog(@"test %@",[NSThread currentThread]);
}];
```

#### 线程状态

![](./11.png)

- [NSThread sleepForTimeInterval:3] 线程睡眠3秒
- [NSThread sleepUntilDate:<#(nonnull NSDate *)#>]; 线程睡眠直到一个时间点才醒
- [NSThread exit] 强制退出，让线程死亡，注意 线程死亡后就不能再start了

**线程属性：**

- thread.name 名字
- thread.threadPriority = 1; 线程优先级 double [0,1] 默认为0.5
  - 优先级：CPU调度时执行下一个线程的概率的感觉，但取不到0%和100%，即使是一个为1一个为0 也不能保证1执行完了才执行0的那个

#### 线程安全问题

线程调用共享资源：一块资源可能被多个线程共享，也就是多个线程都可以访问同一个资源（变量、对象、文件等）

如果多个线程同时访问一块资源时，很容易发生混乱和数据安全问题，比如两个线程都对一个变量减一，都让其减一，如果有个线程读取变量但未进行减一操作（先减一再重新赋值），就到下一个进程了，而下一个进成读取的也是同一个值，那么明明对这个变量减了两次，但变量重复赋值了同一个数字，因此结果只变成减了一次。这就是线程不安全的原因。

**互斥锁**

为了**让线程安全**，我们应该把取值减一赋值**这几个步骤同步执行**，即执行这三个步骤时别的线程进不来。这样就解决了这个问题（这个锁就是**互斥锁**）。也就是**其余线程都会进入sleep**，直到执行完这个锁中的代码后，其他线程才会唤醒，**加锁后会影响性能，因此锁内的应该越少越好**

```objc
- (void)demo{
    while (YES) {
        // 这几个代码应该要同步，不能异步执行，否则会出现线程安全问题。
        // 通常对谁操作，谁（这个对象）就作为锁放进括号中
        @synchronized (self) {
            if (self.number > 0){
                self.number--;
                NSLog(@"%d",self.number);
            }else{
                NSLog(@"--------------");
                break;
            }
        }
        
    }
}
```

注意：互斥锁内不能放死循环。

**自旋锁**：如果其他线程发现一个线程正在执行锁定代码，那么就会进入**死循环**（可以理解为一直等待），**直到这个线程执行完锁内代码**后才跳出循环去这行这个锁定代码，因为是进入死循环这是**十分耗性能**的，所以**自旋锁更适合执行不耗时的代码**

**原子属性**：就是我们在用@property的时候第一个 @property（atomic）加上这个property属性后，这个对象的成员变量就是线程安全的，其实就是系统自动帮我们给属性加了**自旋锁**（在这里只是同时写的时候不出现问题，**不能保证同时读写不出问题**）。默认property就给我们加了原子属性，但是加上了自旋锁效率会变低。

iOS开发建议是，所有属性都用nonatomic，尽量避免多线程争夺同一资源，尽量将加锁、资源抢夺的业务逻辑放在服务器中处理，减小客户端压力

**注意：**iOS中UIKit中大部分对UI的操作都是线程不安全的，因此官方规定，**只能在主线程中操作UI**，因此主线程也叫UI线程。如果想在子线程中操作UI，只能调用`[self performSelectorOnMainThread:SEL withObject:(id)param waitUntilDone:isSynchronize];`

```objc
- (void)viewDidLoad {
    [super viewDidLoad];
    
    [NSThread detachNewThreadWithBlock:^{
        [self demo];
    }];
    NSLog(@"11111");
}
- (void)demo{
    NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:@"https://iknow-pic.cdn.bcebos.com/d043ad4bd11373f092c78684a60f4bfbfbed0434"]];
    NSLog(@"%@",data);
    // 只能在主线程中操作UI
    // 最后一个参数YES则表示，等待这个方法执行完才会执行后面的代码。(是否同步操作)
    [self performSelectorOnMainThread:@selector(showImg:) withObject:[UIImage imageWithData:data] waitUntilDone:NO];
    NSLog(@"render finish");
}
- (void)showImg:(UIImage *)image{
    NSLog(@"render start");
    self.imageView.image = image;
    [self.imageView sizeToFit];
    self.scrollView.contentSize = image.size;
}
```



### GCD



### NSOperation







